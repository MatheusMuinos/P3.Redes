# Comprobación: recvfrom() lee menos datos que sendto()

Objetivo
- Comprobar qué ocurre si el receptor usa un buffer más pequeño que el datagrama enviado por el emisor.
- Ver si es posible recuperar los bytes "restantes" con otra llamada a recvfrom().

Modificaciones realizadas
1. emisor.c
   - Se modifica temporalmente para enviar un datagrama de tamaño controlado (p. ej. 2000 bytes) en vez de leer stdin.
   - Esto garantiza que el datagrama tenga mayor tamaño que el buffer del receptor de prueba.

       /* construir mensagem grande de prueba (2000 bytes) */
    size_t msg_len = 2000;
    char *msg = malloc(msg_len);
    if (!msg) {
        fprintf(stderr, "malloc failed\n");
        close(sock);
        return 1;
    }
    /* preencher com 'A' e terminar com newline para visualização */
    memset(msg, 'A', msg_len-1);
    msg[msg_len-1] = '\n';

    /* envia o datagrama completo */
    sent = sendto(sock, msg, msg_len, 0, (struct sockaddr *)&dest, sizeof(dest));
    if (sent < 0) {
        perror("sendto");
        free(msg);
        close(sock);
        return 1;
    }

    printf("%zd bytes enviados\n", sent);

    free(msg);

2. receptor.c
   - Se modifica para usar un buffer pequeño (p. ej. 1000 bytes).
   - Se usa `recvmsg()` en vez de `recvfrom()` para poder comprobar la bandera `MSG_TRUNC` en `msg_flags`.
   - Se imprime:
     - número de bytes almacenados en el buffer devuelto por `recvmsg()`
     - si la bandera `MSG_TRUNC` está activada (indica truncamiento del datagrama)
   - El receptor realiza UNA lectura y termina (para comprobar si una nueva `recvfrom()` recupera los datos restantes).

   // ...existing code...
    /* buffer pequeno para provocar truncamento (ex.: 1000 bytes) */
    char buf[1000];
    struct sockaddr_in sender;
    socklen_t sender_len = sizeof(sender);

    /* configurar recvmsg para poder inspecionar msg_flags (p.ex. MSG_TRUNC) */
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = sizeof(buf) - 1; /* deixar espaço para terminador */

    struct msghdr msg;
    memset(&msg, 0, sizeof(msg));
    msg.msg_name = &sender;
    msg.msg_namelen = sender_len;
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;

    /* recvmsg bloqueia e devuelve número de bytes armazenados em buf */
    ssize_t n = recvmsg(sock, &msg, 0);
    if (n < 0) {
        perror("recvmsg");
        close(sock);
        return 1;
    }

    /* actualizar sender_len com o tamanho real obtido e terminar string */
    sender_len = msg.msg_namelen;
    buf[(n < (ssize_t)sizeof(buf)) ? n : (sizeof(buf)-1)] = '\0';

    /* obter IP e porta do remetente */
    char ipstr[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &sender.sin_addr, ipstr, sizeof(ipstr));

    /* imprimir informação sobre truncamento e conteúdo recebido */
    printf("Recebidos %zd bytes armazenados no buffer\n", n);
    printf("De %s:%d\n", ipstr, ntohs(sender.sin_port));
    if (msg.msg_flags & MSG_TRUNC) {
        printf("ATENÇÃO: datagrama foi truncado (MSG_TRUNC set). Os bytes restantes foram descartados.\n");
    } else {
        printf("Datagrama recebido sem truncamento.\n");
    }
    printf("Conteúdo armazenado (até %zu bytes):\n%s\n", sizeof(buf)-1, buf);
// ...existing code...

Resultado observado
- UDP es un protocolo de datagramas atómicos: si el datagrama recibido no cabe en el buffer del receptor, el núcleo descarta los bytes que no caben.
- `recvmsg()` puede indicar truncamiento mediante `MSG_TRUNC` en `msg_flags`.
- No es posible recuperar los bytes restantes con una nueva llamada a `recvfrom()`/`recvmsg()`: esos bytes ya fueron descartados por el kernel cuando la primera lectura truncó el datagrama.
- Conclusión práctica: dimensionar el buffer del receptor para contener el datagrama máximo esperado o implementar fragmentación/segmentación en la aplicación (p. ej. enviar en varios datagramas numerados).

Cómo reproducir
1. Compilar:
   gcc -o receptor c:\Users\mathe\Downloads\P3.Redes\receptor.c
   gcc -o emisor c:\Users\mathe\Downloads\P3.Redes\emisor.c

2. Ejecutar receptor (espera un único mensaje y termina):
   ./receptor 12345

3. En otra consola ejecutar emisor (envía datagrama grande):
   ./emisor 50000 127.0.0.1 12345

Observaciones adicionales
- Si necesitas conocer el tamaño real del datagrama aun cuando fue truncado, en algunas plataformas puedes usar `recvmsg()` con la bandera `MSG_TRUNC` (en la llamada) para hacer que la función devuelva la longitud completa del datagrama aunque no cupiera en el buffer; el comportamiento es dependiente del sistema. Sin embargo, aunque conozcas la longitud original, los bytes descartados no se pueden recuperar.

